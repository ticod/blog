---
title: 프로그래머스 주식가격 풀이
date: "2020-11-04T23:54:00.000Z"
description: "프로그래머스의 주식가격 문제를 풀어보았다"
---

# 프로그래머스 주식가격

## Level 2, 스택/큐

알고리즘 문제를 풀고 다른 분들의 풀이를 보며 느꼈던 점이 아, 이렇게 자료구조를 활용 안하고, 배열만 또는 리스트만 쓰면서도 잘만 풀 수 있구나. 너무 갇혀서 생각하지 말자는 게 내 생각이었다. (라고 생각했지만 문제를 보자마자 스택 문제구나 라고 생각했다..) 그래서 두 방식으로 풀었다.

------

## 1. 배열

내가 푼 방식은 **현재 초의 가격**을 보고, (for문으로 index를 훑는다) **가격이 하락한 경우** (이전 가격을 다른 변수에 저장한다. 사실 변수에 따로 저장하는 것은 필수적이지는 않다. 매 번 모든 변수를 현재 가격과 비교하는 방법으로 해결할 수 있다), **가격 하락에 해당하는 이전 시간들의 가격들을 찾아서** (현재 가격보다 높은 가격들을 찾으면 된다) **처리**한다. (현재 초 - 해당 가격이었을 때의 초)

이 방식의 경우, 가격만 가지고서는 아무 것도 할 수 없다는 점이다. 즉, **해당 가격의 시간이 함께 저장**되어야한다. 예시로, 동일 가격의 경우 문제가 생긴다.1초에 2원이었던 가격과 5초에 2원이었던 가격을 10초에 처리하기 위해서는 각 2원이 몇 초에 들어왔는지를 알아야 처리할 수 있다.

처음에 스택을 쓰려 했지만, 더 천천히 생각해 보았다. 가격만 가지고서는 아무 것도 할 수 없다는 점에 근거해서, 오히려 스택보다 배열이 작은 공간에 더 많은 정보를 가지고 있을 수 있다는 생각을 했다.

왜냐하면, 문제를 읽어보면 말 그대로 배열의 인덱스는 곧 시간이다. 즉, **배열 하나에 시간 정보와 그 시간의 가격 정보가 함께 들어있는 것**이다. 이 자체를 활용한다면 매개 변수로 들어오는 배열 하나로 이 문제를 해결할 수 있을 것 같다는 생각을 했다. 만약 스택을 사용한다면? 시간과 가격을 함께 스택에 저장할 방법을 생각해야한다.

```java
// 1. Array 사용
class Solution {
    public int[] solution(int[] prices) {
        int[] seconds = new int[prices.length];
        int currentPrice = 0;

        for (int i = 0; i < prices.length; i++) {
            if (currentPrice > prices[i]) {
                for (int j = 0; j < i; j++) {
                    if (prices[j] > prices[i] && seconds[j] == 0) {
                        seconds[j] = i - j;
                    }
                }
            }
            currentPrice = prices[i];
        }

        for (int i = 0; i < prices.length; i++) {
            if (seconds[i] == 0) {
                seconds[i] = prices.length - 1 - i;
            }
        }

        return seconds;
    }
}
```

첫 번째 for문에서는 시간을 센다. 시간을 세며 가격 변동을 확인한다. 

가격이 하락한다면 이전 가격들을 확인한다. 

이전 가격들 중 현재 가격보다 더 높은 가격이 있다면 그 가격은 지금 하락한 것이다. 여기서 나중에 지금보다 더 가격이 하락하는 경우가 있을 수 있다. 이 경우에는 지금 처리하려는 가격이 또 처리될 수 있다. 이 때문에, 이미 하락했던 가격인지 체크한다. (seconds[j] == 0)

가격을 체크하며 시간을 계산했다. 하지만 끝까지 하락하지 않은 가격들이 있을 것이다. 남은 가격들을 처리해준다. 기준은 마지막 값 즉, 배열의 길이 - 1 인덱스의 시간이 기준이다. 거기서 뺀다.

------

## 2. 스택

배열로도 꽤 잘풀었다고 생각했다. (for문을 두 번 도는 것 빼고...) 하지만 이 것을 스택으로 바꾼 소스를 작성한다고 해도, 더 빨라질지 내 수준으로는 알기 힘들었다. 그래서 직접 스택으로도 풀어보았다.

스택으로 풀 때 고민했던 점은 바로 변수 두 개를 어떻게 저장할 것인지다.

1. class

    가장 간단한 방법이다. 가격과 시간 멤버 변수를 두고, 스택에 클래스를 쌓는 방식으로 한다

2. stack * 2

    클래스를 안쓰고 풀어보고 싶어서 잠시 스쳐지나간 방식이다. 다만 소스도 그렇고 그냥 이 방법을 쓸 바에 클래스를 사용하는 것이 나을 것 같다.

3. String

    구분자를 두고 String으로 저장하는 방식이다. "price,time"과 같이 저장했다면 string.split(",")[0]은 price (물론 형변환을 해줘야 할 것이다), 1은 time이 될 것이다.

4. long

    int형으로는 불가능하다. 문제에서 가격과 시간(prices의 길이)의 범위를 주었다. 이 범위를 가지고 10진법으로 표현한다.

    가격의 범위는 1~10000, 시간은 2~100000이 나온다.

    즉, 100000 00000 + 10000 이런 식으로 하위 다섯자리는 가격, 그 위 6자리는 시간을 표현하는 방법이다.

    뭐.. 개인적으로 해볼까 했던 방식이지만, 굉장히 여러 단점이 있다, 자료의 범위가 달라지면 소스도 갈아 엎어야 할 것이다. (상수를 통해 어느정도 처리가 가능할순 있다) 그리고, 가독성도 굉장히 별로일 것 같다는 생각이 들었다.. 변수 하나로 두 개의 정보를 저장한다.. 나중에 써먹을 곳이 있을 수도 있겠다.

사실 클래스 이외의 방법들은 좀 나사가 하나씩 빠져있기 때문에, 그냥 클래스로 구현했다. 

```java
// 2. Stack 사용
class StockPrice {
    private final int price;
    private final int time;

    StockPrice(int price, int time) {
        this.price = price;
        this.time = time;
    }

    public int getPrice() {
        return price;
    }

    public int getTime() {
        return time;
    }
}

class Solution {
    public int[] solutionStack(int[] prices) {
        int[] seconds = new int[prices.length];
        Stack<StockPrice> priceStack = new Stack<>();
        int currentPrice = 0;

        for (int i = 0; i < prices.length; i++) {
            if (currentPrice > prices[i]) {
                while (priceStack.peek().getPrice() > prices[i]) {
                    StockPrice price = priceStack.pop();
                    seconds[price.getTime()] = i - price.getTime();
                    if (priceStack.isEmpty()) break;
                }
            }
            priceStack.push(new StockPrice(prices[i], i));
            currentPrice = prices[i];
        }

        while (!priceStack.isEmpty()) {
            StockPrice price = priceStack.pop();
            seconds[price.getTime()] = seconds.length - 1 - price.getTime();
        }

        return seconds;
    }
}
```

알고리즘은 배열과 거의 동일하나, 스택의 강점이 드러난다.

이중 for문이 아닌, 안쪽에 while문으로 처리해 준 부분이다.

배열에선 가격을 찾아 탐색을 해야 했다.

스택에서는 현재 가격보다 높은 가격들을 처리하고, 삭제(pop)한다.

그리고 스택에 남은 가격들을 최종 시간에 맞게 처리 해주면 탐색할 필요없이 해결할 수 있었다.



풀고나서 시간을 계산하는 메인 소스를 이용해 두 소스를 비교해 보았다.

![diff.png](.\시간 비교.PNG)

총 테스트 데이터 100만개를 넣고, 같은 배열을 두 방식으로 푼 시간이다.

소스가 나름 깔끔하니 성능도 큰 차이는 안나겠다고 생각했는데 생각 외로, 스택은 너무 빨랐고, 배열은 너무 느렸다.. 너무 신기했다. 이중 포문이 생각보다 시간을 엄청나게 잡아먹는다는 사실을 새삼 깨달았다.. 두 솔루션의 결과 값도 동일했다.

이게 자료구조의 중요성인가? 새삼 깨달았다.. 같은 결과값을 뽑는데에도 이런 시간 차이를 내다니.. 그렇다고 일부로 비효율적으로 짠 것도 아닌데..

알고리즘 문제들은 풀면서도 재밌지만, 이런 배우는 것도 많아서 더 재밌다. 알고리즘 문제와 별개로, 자료구조에 대한 공부는 더욱 해야할 것 같다. 그리고, 알고리즘 문제에서 여러 자료구조를 활용해가면서 문제를 풀어보며, 어떤 상황에선 어떤 자료구조가 최적화하기 좋은지를 더 알아가야겠다.

PS. 풀고나서 다른 분 풀이 보니까 그냥 모든 초를 돌면서 가격 하락할 때까지 세는게 젤 빨라서 굉장히 허무했다... ㅋㅋㅋㅋㅋ 난 이게 느릴 줄 알고 처음에 생각했다가 안써봤는데, 생각해보니 순회는 내가 더 많이 하고 있었던 것이다.. 생각을 아예 안해봤던 방법은 아니긴 해도 이런거 볼 때마다 자괴감든다 ㅠㅠ

